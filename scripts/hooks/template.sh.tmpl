#!/bin/sh
# spcstr hook template
# This template demonstrates the structure for custom hooks
set +e  # Don't exit on error - CRITICAL: Never block Claude Code

# Project and hook paths
PROJECT_PATH="{{.ProjectPath}}"
HOOKS_PATH="{{.HooksPath}}"
LOG_FILE="{{.LogFile}}"

# Source common functions if available
[ -f "${HOOKS_PATH}/common.sh" ] && . "${HOOKS_PATH}/common.sh"

# Ensure log directory exists
log_dir="$(dirname "${LOG_FILE}")"
[ -d "${log_dir}" ] || mkdir -p "${log_dir}" 2>/dev/null || true

# Log function (fallback if common.sh not available)
if ! command -v log_info >/dev/null 2>&1; then
    log_info() {
        printf "[%s] INFO: %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$1" >> "${LOG_FILE}" 2>/dev/null || true
    }
fi

if ! command -v log_error >/dev/null 2>&1; then
    log_error() {
        printf "[%s] ERROR: %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$1" >> "${LOG_FILE}" 2>/dev/null || true
    }
fi

# Hook-specific logic goes here
main() {
    log_info "Hook template executed"
    
    # Example: Access environment variables
    SESSION_ID="${CLAUDE_SESSION_ID:-unknown}"
    
    # Example: Perform operations (with error handling)
    if [ "${SESSION_ID}" != "unknown" ]; then
        log_info "Processing session: ${SESSION_ID}"
        # Add custom logic here
    fi
    
    # Always return success
    return 0
}

# Execute main function
main

# Always exit successfully to not block Claude Code
exit 0